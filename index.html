<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Messay</title><meta name="description" content="坚实而沉重的活着。"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://messay.me/atom.xml" title="Messay"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/lovebaicai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/05/25/Macbook-pro-2015升级硬盘-开机黑屏故障处理/" class="post-title-link">Macbook pro 2015升级硬盘+开机黑屏故障处理</a></h2><div class="post-info">May 25, 2020</div><div class="post-content"><h4 id="最近买了一台二手的丐版macbook-pro-2015款-13寸，很是好用。美中不足的是硬盘只有128G，故研究了一下升级ssd的过程。升级过程比较简单，此文主要说的是一些升级过程中遇到的问题以及解决方法。"><a href="#最近买了一台二手的丐版macbook-pro-2015款-13寸，很是好用。美中不足的是硬盘只有128G，故研究了一下升级ssd的过程。升级过程比较简单，此文主要说的是一些升级过程中遇到的问题以及解决方法。" class="headerlink" title="最近买了一台二手的丐版macbook pro 2015款 13寸，很是好用。美中不足的是硬盘只有128G，故研究了一下升级ssd的过程。升级过程比较简单，此文主要说的是一些升级过程中遇到的问题以及解决方法。"></a>最近买了一台二手的丐版macbook pro 2015款 13寸，很是好用。美中不足的是硬盘只有128G，故研究了一下升级ssd的过程。升级过程比较简单，此文主要说的是一些升级过程中遇到的问题以及解决方法。</h4><h4 id="一-升级过程问题："><a href="#一-升级过程问题：" class="headerlink" title="一. 升级过程问题："></a>一. 升级过程问题：</h4><ul>
<li>升级硬盘安装过程非常简单，网上已有大量的博文介绍，在此不在多写。我使用的是经过大量网友验证的 <code>Intel 760p</code>，确实很稳；</li>
<li><p>拆机过程中，强烈建议将电池连接断开，防止因带电操作，造成硬件损坏。电池是用一个卡扣连在主板上的，稍微向上用点力就可以扣下来。此处盗用一个图：</p>
<p><img src="https://i.loli.net/2020/05/25/YNFheC9K3BRygEw.jpg" alt="image-20191124185433480.jpg"></p>
</li>
<li><p>特别需要注意的是macOS仅在10.13版本，也就是 <code>High Sierra</code> 才开始原生支持nvme驱动。这个版本之前的macOS都是不支持nvme驱动的。故安装系统最低也要安装10.13版本，建议安装 <code>macOS 10.14（Mojave）</code> 版本；</p>
</li>
<li><p>在装好ssd，重新恢复系统的时候，特别注意的是要使用装有10.13+版本的U盘来启动。一般来说Macbook 2015初始的系统，都是10.13之前的系统，如果使用网络恢复模式，是无法在磁盘管理中找到nvme的硬盘的，我就碰到了这个问题。后面在更换使用10.14版本的U盘启动才可以识别到新的nvme硬盘。U盘制作方法可参考：<a href="https://support.apple.com/zh-cn/HT201372" target="_blank" rel="noopener">如何创建可引导的 macOS 安装器
</a></p>
</li>
<li><p>如果安装完成能正常启动，没有其他问题，那么到此，硬盘升级就完成。</p>
</li>
</ul></div><a href="/2020/05/25/Macbook-pro-2015升级硬盘-开机黑屏故障处理/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/08/30/Prometheus联邦集群-Alertmanager电话报警配置示例说明/" class="post-title-link">Prometheus联邦集群+Alertmanager电话报警配置示例说明</a></h2><div class="post-info">Aug 30, 2019</div><div class="post-content"><h4 id="目前公司有两个业务线，所以搭建了两套Kubernetes集群用来部署不同业务，每套集群内部都是用容器部署了一套Prometheus监控自身的业务。基于数据易于分析和预警及时的考虑，故整合两个集群的Prometheus数据到外层的一个Prometheus里，并增加高级别异常电话告警。联邦集群的原理这里不在赘述，各组件具体配置示例如下："><a href="#目前公司有两个业务线，所以搭建了两套Kubernetes集群用来部署不同业务，每套集群内部都是用容器部署了一套Prometheus监控自身的业务。基于数据易于分析和预警及时的考虑，故整合两个集群的Prometheus数据到外层的一个Prometheus里，并增加高级别异常电话告警。联邦集群的原理这里不在赘述，各组件具体配置示例如下：" class="headerlink" title="目前公司有两个业务线，所以搭建了两套Kubernetes集群用来部署不同业务，每套集群内部都是用容器部署了一套Prometheus监控自身的业务。基于数据易于分析和预警及时的考虑，故整合两个集群的Prometheus数据到外层的一个Prometheus里，并增加高级别异常电话告警。联邦集群的原理这里不在赘述，各组件具体配置示例如下："></a>目前公司有两个业务线，所以搭建了两套<code>Kubernetes</code>集群用来部署不同业务，每套集群内部都是用容器部署了一套<code>Prometheus</code>监控自身的业务。基于数据易于分析和预警及时的考虑，故整合两个集群的<code>Prometheus</code>数据到外层的一个<code>Prometheus</code>里，并增加高级别异常电话告警。联邦集群的原理这里不在赘述，各组件具体配置示例如下：</h4></div><a href="/2019/08/30/Prometheus联邦集群-Alertmanager电话报警配置示例说明/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/08/20/使用log-pilot收集ingress日志/" class="post-title-link">使用log-pilot收集ingress日志</a></h2><div class="post-info">Aug 20, 2019</div><div class="post-content"><h4 id="在Kubernetes集群内收集ingress日志，我们是直接使用了阿里开源的log-pilot做为采集端，将日志经logstash过滤，在汇聚到elasticsearch进行分析。各组件配置示例如下："><a href="#在Kubernetes集群内收集ingress日志，我们是直接使用了阿里开源的log-pilot做为采集端，将日志经logstash过滤，在汇聚到elasticsearch进行分析。各组件配置示例如下：" class="headerlink" title="在Kubernetes集群内收集ingress日志，我们是直接使用了阿里开源的log-pilot做为采集端，将日志经logstash过滤，在汇聚到elasticsearch进行分析。各组件配置示例如下："></a>在Kubernetes集群内收集ingress日志，我们是直接使用了阿里开源的<strong>log-pilot</strong>做为采集端，将日志经<strong>logstash</strong>过滤，在汇聚到<strong>elasticsearch</strong>进行分析。各组件配置示例如下：</h4><h4 id="一、log-pilot本质上也是一个日志的采集端，内部封装了filebeat和fluentd两种不同的采集工具，我们使用的是filebeat。"><a href="#一、log-pilot本质上也是一个日志的采集端，内部封装了filebeat和fluentd两种不同的采集工具，我们使用的是filebeat。" class="headerlink" title="一、log-pilot本质上也是一个日志的采集端，内部封装了filebeat和fluentd两种不同的采集工具，我们使用的是filebeat。"></a>一、<strong>log-pilot</strong>本质上也是一个日志的采集端，内部封装了<strong>filebeat</strong>和<strong>fluentd</strong>两种不同的采集工具，我们使用的是<strong>filebeat</strong>。</h4></div><a href="/2019/08/20/使用log-pilot收集ingress日志/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/08/08/为Kubernetes配置Pod生命周期的附加操作程序/" class="post-title-link">为Kubernetes配置Pod生命周期的附加操作程序</a></h2><div class="post-info">Aug 8, 2019</div><div class="post-content"><h4 id="最近发现集群内的POD在删除的时候，不会自动清理某些自定义配置的网络信息。于是使用了Kubernets的一个功能，在删除或者启动POD的时候，去触发自定义的一些处理程序，避免POD在删除的时候遗留某些信息导致的集群异常。示例如下："><a href="#最近发现集群内的POD在删除的时候，不会自动清理某些自定义配置的网络信息。于是使用了Kubernets的一个功能，在删除或者启动POD的时候，去触发自定义的一些处理程序，避免POD在删除的时候遗留某些信息导致的集群异常。示例如下：" class="headerlink" title="最近发现集群内的POD在删除的时候，不会自动清理某些自定义配置的网络信息。于是使用了Kubernets的一个功能，在删除或者启动POD的时候，去触发自定义的一些处理程序，避免POD在删除的时候遗留某些信息导致的集群异常。示例如下："></a>最近发现集群内的POD在删除的时候，不会自动清理某些自定义配置的网络信息。于是使用了Kubernets的一个功能，在删除或者启动POD的时候，去触发自定义的一些处理程序，避免POD在删除的时候遗留某些信息导致的集群异常。示例如下：</h4><ul>
<li>Kubernetes在启动Container后立即发送postStart事件，并在Container终止之前立即发送preStop事件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: lifecycle-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: lifecycle-demo-container</span><br><span class="line">    image: nginx</span><br><span class="line">    lifecycle:</span><br><span class="line">      postStart:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;]</span><br><span class="line">      preStop:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;nginx -s quit; while killall -0 nginx; do sleep 1; done&quot;]</span><br></pre></td></tr></table></figure></div><a href="/2019/08/08/为Kubernetes配置Pod生命周期的附加操作程序/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/08/03/为Kubernetes集群内的Pod配置NFS存储/" class="post-title-link">为Kubernetes集群内的Pod配置NFS存储</a></h2><div class="post-info">Aug 3, 2019</div><div class="post-content"><h4 id="近一段时间在做容器化的项目，公司需要把nginx也放到kubernetes集群内，nginx有静态资源，如果在每个node节点都同步一份感觉太费劲，所以使用nfs挂载到pod内部使用。pod使用nfs存储有两种方法，介绍如下"><a href="#近一段时间在做容器化的项目，公司需要把nginx也放到kubernetes集群内，nginx有静态资源，如果在每个node节点都同步一份感觉太费劲，所以使用nfs挂载到pod内部使用。pod使用nfs存储有两种方法，介绍如下" class="headerlink" title="近一段时间在做容器化的项目，公司需要把nginx也放到kubernetes集群内，nginx有静态资源，如果在每个node节点都同步一份感觉太费劲，所以使用nfs挂载到pod内部使用。pod使用nfs存储有两种方法，介绍如下:"></a>近一段时间在做容器化的项目，公司需要把nginx也放到kubernetes集群内，nginx有静态资源，如果在每个node节点都同步一份感觉太费劲，所以使用nfs挂载到pod内部使用。pod使用nfs存储有两种方法，介绍如下:</h4><h4 id="一、在pod直接挂载nfs存储"><a href="#一、在pod直接挂载nfs存储" class="headerlink" title="一、在pod直接挂载nfs存储"></a>一、在pod直接挂载nfs存储</h4><div class="tip">特别注意: 使用此种方法在pod里挂载nfs,务必要在pod所调度的节点上安装<strong>nfs-utils</strong>,否则无法挂载!!!</div>

<ul>
<li><p>最近的几个Kubernetes大版本已经原生支持在pod内部直接挂载nfs存储，只需把volumes的类型改成nfs就行，示例如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kind: Pod</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-in-a-pod</span><br><span class="line">spec:</span><br><span class="line">  # hostNetwork: true</span><br><span class="line">  containers:</span><br><span class="line">    - name: app</span><br><span class="line">      image: alpine</span><br><span class="line">      volumeMounts:</span><br><span class="line">        - name: nfs-volume</span><br><span class="line">          mountPath: /var/nfs</span><br><span class="line">      command: [&quot;/bin/sh&quot;]</span><br><span class="line">      args: [&quot;-c&quot;, &quot;sleep 5000000000&quot;]</span><br><span class="line">  volumes:</span><br><span class="line">    - name: nfs-volume</span><br><span class="line">      nfs:</span><br><span class="line">        server: 192.168.7.107</span><br><span class="line">        path: /tmp/nfs_test</span><br></pre></td></tr></table></figure>
</li>
</ul></div><a href="/2019/08/03/为Kubernetes集群内的Pod配置NFS存储/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/08/03/两步清理Harbor磁盘空间/" class="post-title-link">两步清理Harbor磁盘空间</a></h2><div class="post-info">Aug 3, 2019</div><div class="post-content"><h4 id="测试环境的Harbor磁盘已经不堪重负-一天不知道多少个迭代测试包丢上面，清理已经刻不容缓。因公司使用Harbor版本比较老，无法在线清理，故需要两步清理：先删除不需要的tag，然后在使用garbage-collection-GC-回收磁盘空间。"><a href="#测试环境的Harbor磁盘已经不堪重负-一天不知道多少个迭代测试包丢上面，清理已经刻不容缓。因公司使用Harbor版本比较老，无法在线清理，故需要两步清理：先删除不需要的tag，然后在使用garbage-collection-GC-回收磁盘空间。" class="headerlink" title="测试环境的Harbor磁盘已经不堪重负,一天不知道多少个迭代测试包丢上面，清理已经刻不容缓。因公司使用Harbor版本比较老，无法在线清理，故需要两步清理：先删除不需要的tag，然后在使用garbage collection(GC)回收磁盘空间。"></a>测试环境的Harbor磁盘已经不堪重负,一天不知道多少个迭代测试包丢上面，清理已经刻不容缓。因公司使用Harbor版本比较老，无法在线清理，故需要两步清理：先删除不需要的tag，然后在使用garbage collection(GC)回收磁盘空间。</h4><div class="tip">Harbor已经在1.7.0版本支持在线清理空间.</div></div><a href="/2019/08/03/两步清理Harbor磁盘空间/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/07/27/mega网盘命令行模式使用说明/" class="post-title-link">mega网盘命令行模式使用说明</a></h2><div class="post-info">Jul 27, 2019</div><div class="post-content"><h4 id="之前买了一台小鸡是打算做梯子用的，但是搭的梯子质量并不是很好，时断时续。于是想着不能浪费就在上面搭了一个transmission用来下载bt。毕竟是台小鸡，网络传输还是慢，下载的东西传到本地机器还是很慢，于是就用mega代理了一下，先上传到mega上，然后在下载到本地，所以使用mega命令行来操作。"><a href="#之前买了一台小鸡是打算做梯子用的，但是搭的梯子质量并不是很好，时断时续。于是想着不能浪费就在上面搭了一个transmission用来下载bt。毕竟是台小鸡，网络传输还是慢，下载的东西传到本地机器还是很慢，于是就用mega代理了一下，先上传到mega上，然后在下载到本地，所以使用mega命令行来操作。" class="headerlink" title="之前买了一台小鸡是打算做梯子用的，但是搭的梯子质量并不是很好，时断时续。于是想着不能浪费就在上面搭了一个transmission用来下载bt。毕竟是台小鸡，网络传输还是慢，下载的东西传到本地机器还是很慢，于是就用mega代理了一下，先上传到mega上，然后在下载到本地，所以使用mega命令行来操作。"></a>之前买了一台小鸡是打算做梯子用的，但是搭的梯子质量并不是很好，时断时续。于是想着不能浪费就在上面搭了一个transmission用来下载bt。毕竟是台小鸡，网络传输还是慢，下载的东西传到本地机器还是很慢，于是就用mega代理了一下，先上传到mega上，然后在下载到本地，所以使用mega命令行来操作。</h4><div class="tip">mega网盘确实蛮好用的，免费的也基本够用了</div>


<h4 id="mega命令行使用："><a href="#mega命令行使用：" class="headerlink" title="mega命令行使用："></a>mega命令行使用：</h4><ul>
<li>基本操作：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 先进入mega命令行模式</span><br><span class="line"># mega-cmd</span><br><span class="line"></span><br><span class="line"># 以下所有操作全是都是在mega-cmd命令行模式进行</span><br><span class="line"></span><br><span class="line"># 使用login命令，登录成功不会显示成功之类的信息，会直接进入默认用户的目录,下图</span><br><span class="line">login yourname@mail.com|username password       # 登录</span><br><span class="line">logout                                          # 登出</span><br><span class="line">quit|exit                                       # 退出</span><br><span class="line"></span><br><span class="line"># 基础操作(同linux)</span><br><span class="line">cd /pathname                                   # 进入目录</span><br><span class="line">ls /pathname                                   # 查看目录文件</span><br><span class="line">mkdir /pathname                                # 创建文件夹</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><a href="/2019/07/27/mega网盘命令行模式使用说明/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/07/20/搭建DNS管理平台的一些注意要点/" class="post-title-link">搭建DNS管理平台的一些注意要点</a></h2><div class="post-info">Jul 20, 2019</div><div class="post-content"><h4 id="公司内部一直缺少一个管理DNS的平台，故搭建了一个WEB页面，用来管理内部的DNS解析。期间遇到的一些坑，分享一下。"><a href="#公司内部一直缺少一个管理DNS的平台，故搭建了一个WEB页面，用来管理内部的DNS解析。期间遇到的一些坑，分享一下。" class="headerlink" title="公司内部一直缺少一个管理DNS的平台，故搭建了一个WEB页面，用来管理内部的DNS解析。期间遇到的一些坑，分享一下。"></a>公司内部一直缺少一个管理DNS的平台，故搭建了一个WEB页面，用来管理内部的DNS解析。期间遇到的一些坑，分享一下。</h4><h4 id="一、BIND-DNS主从模式选择"><a href="#一、BIND-DNS主从模式选择" class="headerlink" title="一、BIND-DNS主从模式选择"></a>一、BIND-DNS主从模式选择</h4><ul>
<li>如果使用web页面来管理DNS，其实BIND-DNS最方便的是主和从都采用数据库作为后端数据存储。主DNS使用主数据库，然后从DNS使用从数据库。然后web页面修改了主数据库后，那么从数据库也会实时同步更新。达到DNS主从同步的目的；</li>
<li>采用以上方法虽然简单，但是一个致命的问题。就是如果使用数据库作为DNS的后端存储，那么DNS的解析速度是远远不如使用文件作为后端数据存储的(对比下图)；</li>
<li>综上，故建议主DNS使用数据库存储，然后web页面管理主DNS。而从DNS使用文件存储，每次修改主DNS数据库，自动同步数据到从DNS的文件上，所有的主机使用从DNS作为DNS服务器，达到管理方便和解析快速的双重目的；</li></ul></div><a href="/2019/07/20/搭建DNS管理平台的一些注意要点/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/07/16/Centos6-10-安装Docker-17-03-2-ce/" class="post-title-link">Centos6.10 安装Docker 17.03.2-ce</a></h2><div class="post-info">Jul 16, 2019</div><div class="post-content"><h4 id="前两天需要在Centos6上面封装docker镜像需要安装docker，但是发现在Centos6上安装docker只能安装docker-1-7-1版本。此版本推送镜像到harbor验证有问题，故需要升级docker版本到17-03-2-ce。"><a href="#前两天需要在Centos6上面封装docker镜像需要安装docker，但是发现在Centos6上安装docker只能安装docker-1-7-1版本。此版本推送镜像到harbor验证有问题，故需要升级docker版本到17-03-2-ce。" class="headerlink" title="前两天需要在Centos6上面封装docker镜像需要安装docker，但是发现在Centos6上安装docker只能安装docker 1.7.1版本。此版本推送镜像到harbor验证有问题，故需要升级docker版本到17.03.2-ce。"></a>前两天需要在Centos6上面封装docker镜像需要安装docker，但是发现在Centos6上安装docker只能安装docker 1.7.1版本。此版本推送镜像到harbor验证有问题，故需要升级docker版本到17.03.2-ce。</h4><div class="tip">特别注意,编译安装过程极度依赖梯子,否则安装很难成功!</div>


<h4 id="一、升级内核"><a href="#一、升级内核" class="headerlink" title="一、升级内核"></a>一、升级内核</h4><ul>
<li>在centos6上安装docker17.03.2，需要先将内核升级到3.10版本(未考证?)，故直接安装最新稳定版内核</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -Uvh http://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm</span><br><span class="line">yum install kernel-lt -y</span><br><span class="line">sed -i &apos;s/default=1/default=0/g&apos; /etc/grub.conf</span><br><span class="line">reboot</span><br><span class="line">uname -sr  #Linux 4.4.185-1.el6.elrepo.x86_64</span><br></pre></td></tr></table></figure>
<h4 id="二、安装依赖docker环境"><a href="#二、安装依赖docker环境" class="headerlink" title="二、安装依赖docker环境"></a>二、安装依赖docker环境</h4><ul>
<li>docker 17.03.2安装全部都是在docker里面完成的，故需要安装一个老版本的docker，才能编译安装17.03版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 安装1.7.1版本</span><br><span class="line">rpm -ivfh https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm</span><br><span class="line">yum install https://get.docker.com/rpm/1.7.1/centos-6/RPMS/x86_64/docker-engine-1.7.1-1.el6.x86_64.rpm</span><br><span class="line"></span><br><span class="line">docker version # version: 1.7.1</span><br><span class="line"></span><br><span class="line">#下载1.9.1然后替换</span><br><span class="line">curl -sSL -O https://get.docker.com/builds/Linux/x86_64/docker-1.9.1</span><br><span class="line">chmod +x docker-1.9.1</span><br><span class="line">mv docker-1.9.1 /usr/bin/docker</span><br><span class="line"> </span><br><span class="line">service docker restart</span><br><span class="line"></span><br><span class="line">docker version # version: 1.9.1</span><br></pre></td></tr></table></figure></div><a href="/2019/07/16/Centos6-10-安装Docker-17-03-2-ce/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/07/14/DNS各类型互斥关系说明/" class="post-title-link">DNS各类型互斥关系说明</a></h2><div class="post-info">Jul 14, 2019</div><div class="post-content"><h4 id="前段时间完成了公司内部DNS解析平台的搭建，内里有许多坑，其中一个的就是DNS各种类型的互斥关系，简单说明如下。"><a href="#前段时间完成了公司内部DNS解析平台的搭建，内里有许多坑，其中一个的就是DNS各种类型的互斥关系，简单说明如下。" class="headerlink" title="前段时间完成了公司内部DNS解析平台的搭建，内里有许多坑，其中一个的就是DNS各种类型的互斥关系，简单说明如下。"></a>前段时间完成了公司内部DNS解析平台的搭建，内里有许多坑，其中一个的就是DNS各种类型的互斥关系，简单说明如下。</h4><h4 id="DNS有下列几种类型："><a href="#DNS有下列几种类型：" class="headerlink" title="DNS有下列几种类型："></a>DNS有下列几种类型：</h4><ul>
<li>A记录： 将域名指向一个IPv4地址（例如：100.100.100.100），需要增加A记录;</li>
<li>CNAME记录： 如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。这个域名一般是主机服务商提供的一个域名;</li>
<li>MX记录： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录;</li>
<li>NS记录： 域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录;</li>
<li>TXT记录： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录;</li>
<li>AAAA记录： 将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录;</li>
<li>SRV记录： 添加服务记录服务器服务记录时会添加此项，SRV记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）;</li>
<li>SOA记录： SOA叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中那一台是主服务器;</li>
<li>PTR记录： PTR记录是A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名;</li>
<li>显性URL转发记录： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址。例如：将<a href="http://www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com" target="_blank" rel="noopener">www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com</a>;</li>
<li>隐性UR转发记录L： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：将<a href="http://www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.liuht.cn" target="_blank" rel="noopener">www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.liuht.cn</a>;</li>
</ul></div><a href="/2019/07/14/DNS各类型互斥关系说明/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2020 <a href="http://messay.me">Messay</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>